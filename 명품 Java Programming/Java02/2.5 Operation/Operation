연산자 -> ㅈ도 없다. 걍 C/C++에서 하던거랑 매우 흡사

우선 순위
- ++(postfix), --(postfix)
- +(양수 부호), -(음수 부호), ++(prefix), --(prefix), ~, !
- (type casting)
- *, /, %
- +(덧셈), -(뺄셈)
- <<, >>, >>> [시프트 연산]
- <, >, <=, >=, instanceof
- ==, !=
- &(And)
- ^(Xor)
- |(Or)
- &&(And)
- ||(Or)
- ? :
- =, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=

비트 연산
 - 비트 논리 연산: &(AND), |(OR), ^(XOR), ~(NOT)
 - 비트 시프트 연산: <<, >>, >>>
 
비트: 컴퓨터의 모든 정보는 0, 1의 값을 가지는 이진수로 다뤄지고 저장된다. 이진수의 한 자리를 비트(bit)라고 한다.
바이트(Byte): 8bit

비트 시프트 연산: 산술적 시프트와 논리적 시프트가 있다.

- a >> b: a의 각 비트를 오른쪽으로 b번 시프트 연산, 최상위 비트의 빈자리는 시프트 전의 최상위 비트로 다시 채운다.
-> 산술적 오른쪽 시프트

- a >>> b: a의 각 비트를 오른쪽으로 b번 시프트 연선, 최상위 비트의 빈자리는 항상 0으로 채운다.
-> 논리적 오른쪽 시프트

- a << b: a읙 각 비트를 왼쪽으로 b번 시프트 연산, 최하위 비트의 빈자리는 항상 0으로 채운다.
-> 산술적 왼쪽 시프트
-> 음수를 시프트하면 최상위 비트가 0이 되어 양수로 오버플로우가 일어날 수 있다. 

최상위 비트(MSB): 수를 표현하는 이진수의 제일 높은 자리수
최하위 비트(LSB): 수를 표현하는 이진수의 제일 낮은 자리수

21 = 00010101
MSB(21) = 0, LSB(21) = 1

시프트 연산의 피연산자: byte, short, int, long, char 타입만 가능  
생성자(Constructor)

-> 객체가 생성될 때 객체의 초기화를 위해 실행되는 메소드
-> 객체가 생성되는 순간에 자동으로 호출되는 메소드 -> 객체 초기화에 필요한 코드가 담긴다
-> Ex0403

- 생성자의 이름은 클래스의 이름과 동일하다.

- 생성자는 여러 개 작성(오버로딩)할 수 있다.
-> 매개변수의 개수와 타입만 다르다면 가능하다.

- 생성자는 new를 통해 객체를 생성할 때 한 번만 호출된다.
-> 객체 생성은 반드시 new로 이루어지고, 이 경우를 제외하고는 생성자는 호출되지 않는다.

- 생성자에는 리턴 타입이 없다. -> void도 쓰지마.
-> 하 지 만 return을 사용할 수 있다. -> 생성자의 실행을 끝내고 싶은 부분에서 return;을 쓰면 실행이 끝나고 호출로 돌아간다.

- 생성자의 목적
-> 객체가 생성될 때, 필요한 초기 작업을 하기 위함


기본 생성자(Default Constructor)
-> 매개변수와 실행코드 없이 아무일도 하지 않고 단순 리턴하는 생성자, 디폴트 생성자
-> 생성자가 정의되지 않은 경우, 컴파일러가 자동으로 생성한다.
-> 생성자가 하나라도 존재하면 기본 생성자는 실행되지 않는다.
  -> 그러면 문제가 생긴다.
  
  public Circle(int r) { radius = r; }	// 생성자 선언 -> 기본 생성자 없음
  Circle donut = new Circle();			// 어라? 생성자 Circle()은 없네? -> 컴파일 에러
  -> C++과는 다르게 int r=1 이런식으로 사용하는 것은 안되더라
 
this 레퍼런스
-> 객체 자기 자신을 가리키는 레퍼런스
-> 현재 실행되고 있는 메소드가 속한 객체에 대한 레퍼런스, 컴파일러에 의해 자동으로 관리 됨 -> 개발자는 사용하면 끝

public Circle(int r) { this.radius = r; }
-> 현재 객체에 대한 레퍼런스, 현재 객체인 멤버 radius를 접근

this의 필요성
-> 클래스 내에서 멤버를 접근할 때는 this가 굳이 필요하지 않다.

하지만, 매개변수의 이름을 radius로 하고싶다면, radius = radius라는 이상한 코드가 만들어지고,
이 상황에서 this.radius = radius;
내가 가리키는 객체 = 매개변수 의 형식으로 사용할 수 있게 된다.

또한, 객체 자신의 레퍼런스를 리턴하는 경우, return this; 와 같이 리턴한다.


this()의 다른 생성자 호출
-> 클래스 내에서 생성자가 다른 생성자를 호출할 때 사용
1. this는 자기 자신에 대한 레퍼런스
2. this와 this()는 다르다
3. this는 메소드에서 사용, 현재 객체를 가리킴
4. 하지만, static 메소드에서는 사용 불가

주의 사항!
1. this()는 반드시 생성자 코드에서 사용
2. this()는 반드시 같은 클래스 내에서 다른 생성자를 호출할 때 사용
3. this()는 반드시 생성자의 첫 번째 문장 -> 늦게 나오면 컴파일 에러


객체 치환 시 주의점
-> = 연산자로 객체를 치환하면 치환(대입)은 이루어짐
ob1 ob2가 있고, s=ob2, ob1 = ob2라고 하자
-> s는 ob2 객체를 가리키는 레퍼런스
-> ob1은 ob2 객체를 가리키게 된다.
-> ob1의 내용은 낙동강 오리알이 된다. -> 가비지(garbage) -> JVM에 의해 자동 수거

























